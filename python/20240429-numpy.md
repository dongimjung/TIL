Pandas를 포스팅 하기 전 Numpy를 먼저 포스팅 했어야 하는데 순서가 잘못되었다.

왜냐하면, Pandas는 Numpy를 근간으로 만들어졌기 때문이다.(Pandas 뿐만 아니라 Scikit-learn, matplotlib 등 오만가지 라이브러리들이 웬만하면 Numpy에 dependency가 있다.)

## 그렇다면 Numpy란 무엇일까.

Numpy는 파이썬에서 "수치 연산"에 특화된 핵심 라이브러리이다.

주로 다차원 배열(array)과 행렬(matrix)을 다루는 데에 특화되어 있다(딱 들었을 때 _벡터연산과 관련이 있을 것 같다는 느낌이 강하게 든다._) 

## 왜 Numpy가 수치연산에 특화되어있다는 것일까? 파이썬은 수치연산을 못하는건가?

\-> 못하지는 않지만 느리고 가끔 부정확하다. 

프로그램이 수치연산이 부정확하는게 말이 되는가?!

가끔 그렇다.

## Numpy의 배열과, 비슷한 개념인 파이썬의 리스트와의 차이점을 정리해보았다.

|   | \[Python\] List | \[Numpy\] Array |
| --- | --- | --- |
| 내부구조 | 서로 다른 데이터 유형을 포함할 수 있는 동적 배열 | 각 요소는 동일한 데이터 유형을 가져야 한다.   생성하고 나서 크기가 정해지고, 이는 변경될 수 없다.(굳이 변경해야 한다면 복사의 개념으로)   원소변경은 가능하다는 점이 튜플과의 차이. |
| 성능 | 동적 배열로 구현되어 있어 데이터 처리 및 연산이 느릴 수 있다. 각 요소에 대한 접근 및 수정에는 반복문이 필요 | 넘파이 배열은 C 언어로 구현되어 있어 데이터 처리 및 연산에서 매우 효율적이다. 벡터화된 연산을 통해 반복문 없이 대량의 데이터를 빠르게 처리할 수 있다(물론 c코드 내부적으로는 반복을 하지만..) |
| 기능 | 일반적인 데이터 컨테이너로서 요소 추가, 삭제, 슬라이싱 등의 기본적인 기능을 제공 | 다양한 수학 및 선형 대수 연산을 지원. 행렬 곱셈, 요소별 연산, 배열 합치기 등의 작업을 편리하게 수행할 수 있다.   연산시  “브로드 캐스팅”, "Universal function". |
| 메모리 사용량 | 메모리 사용량이 넘파이 배열보다 큰 경우가 많다. | 데이터 유형(dtype)에 따라 효율적으로 메모리를 사용하므로 메모리 사용량이 적다 |

따라서, 데이터 처리와 연산이 주된 목적이라면 넘파이 배열을 사용하는 것이 좋다. 하지만 데이터 유형이 다양하고 유연성이 필요한 경우에는 파이썬 리스트를 사용하는 것이 적합할 수 있다.

## 다음은 자주 사용되는 Numpy의 함수이다.

| 함수 | 설명 | 예시 |
| --- | --- | --- |
| np.array() | 주어진 객체를 배열로 변환 | np.array(\[1, 2, 3, 4, 5\]) |
| np.arange() | 지정된 범위의 값을 가진 배열을 생성 | np.arange(0, 10, 2)     # 0부터 10까지 2씩 증가하는 배열 생성 |
| np.linspace() | 시작점부터 종료점까지 균일한 간격으로 값을 포함하는 배열을 생성 | np.linspace(0, 10, 5)     # 0부터 10까지 5개의 값으로 균일하게 나눈 배열 생성 |
| np.zeros() | 모든 요소가 0인 배열을 생성 | np.zeros((2, 3))     # 2x3 모양의 0으로 채워진 배열 생성 |
| np.ones() | 모든 요소가 1인 배열을 생성 | np.ones((3, 2))   |
| np.eye() | 단위 행렬(Identity Matrix)을 생성 | np.eye(3)     # 3x3 크기의 단위 행렬 생성 |
| np.random.rand() | 0과 1 사이의 균일 분포를 가진 난수 배열을 생성 | np.random.rand(2, 3) |
| np.random.randn() | 평균이 0이고 표준 편차가 1인 정규 분포를 따르는 난수 배열을 생성 | np.random.randn(3, 3) |
| np.vstack() | 배열 세로로 합치기 | np.vstack(\[arr1, arr2\]) |
| np.hstack() | 배열 가로로 합치기 | np.hstack(\[arr1, arr2\]) |
| np.sum() | 배열의 모든 요소의 합을 계산 | np.sum(arr) |
| np.mean() | 배열의 모든 요소의 평균을 계산 | np.mean(arr) |
| np.min() | 배열 내의 최솟값을 반환 | np.min(arr) |
| np.median() | 배열의 중앙값을 반환 | np.median(arr) |
| np.std() | 배열의 표준편차를 반환 | np.std(arr) |
| np.abs() | 배열의 모든 요소의 절대값 | np.abs(arr) |
| np.square(arr) | 배열의 모든 요소의 제곱 | np.square(arr) |
| np.sqrt(arr) | 배열의 모든 요소의 제곱근 | np.sqrt(arr) |

\- pandas에도 집계함수들이 있으니 헷갈리지 말고 잘 선택해서 쓰자. ex) df\['col'\].mean()

※ 오늘의 팁

```
np.random.seed(42)
```

\-> 랜덤은 쓰되, 그 랜덤값은 고정하고 싶다!! 실험에 통제해야 하는 경우가 많으니까.
